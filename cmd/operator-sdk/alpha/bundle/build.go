package bundle

import (
	"os"
	"path/filepath"

	"github.com/operator-framework/operator-registry/pkg/lib/bundle"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

// newBundleBuildCmd returns a command that will build operator bundle image.
func newBundleBuildCmd() *cobra.Command {
	c := bundleCmd{}
	cmd := &cobra.Command{
		Use:   "build",
		Short: "Build an operator bundle image",
		Long: `The 'operator-sdk bundle build' command will build an operator
bundle image containing operator metadata and manifests, tagged with the
provided image tag. Metadata generated by this command defines this image
and should not be modified.

If you wish to use a non-default image builder, run the 'generate' subcommand
and build the operator's bundle image manually.

NOTE: bundle images are not runnable.
`,
		Example: `The following command will build a test-operator bundle image using Docker.
This image will contain manifests for package channels 'stable' and 'beta':

$ operator-sdk bundle build \
    --directory ./deploy/olm-catalog/test-operator \
    --tag quay.io/example/operator:v0.1.0 \
    --package test-operator \
    --channels stable,beta \
    --default stable \
    --overwrite
`,
		RunE: func(cmd *cobra.Command, args []string) error {
			// Clean up transient metadata and Dockerfile once the image is built,
			// as they are no longer needed.
			metaDir := filepath.Join(c.directory, "metadata")
			_, err := os.Stat(metaDir)
			metaExists := os.IsExist(err)
			dockerFile := filepath.Join(c.directory, "Dockerfile")
			_, err = os.Stat(dockerFile)
			dockerFileExists := os.IsExist(err)
			defer func() {
				if !metaExists {
					_ = os.RemoveAll(metaDir)
				}
				if !dockerFileExists {
					_ = os.RemoveAll(dockerFile)
				}
			}()
			return bundle.BuildFunc(c.directory, c.imageTag, c.imageBuilder,
				c.packageName, c.channels, c.channelDefault, c.overwrite)
		},
	}

	cmd.Flags().StringVarP(&c.directory, "directory", "d", "",
		"The directory where bundle manifests are located")
	if err := cmd.MarkFlagRequired("directory"); err != nil {
		log.Fatalf("Failed to mark `directory` flag for `build` subcommand as required")
	}
	cmd.Flags().StringVarP(&c.packageName, "package", "p", "",
		"The name of the package that bundle image belongs to")
	if err := cmd.MarkFlagRequired("package"); err != nil {
		log.Fatalf("Failed to mark `package` flag for `build` subcommand as required")
	}
	cmd.Flags().StringVarP(&c.channels, "channels", "c", "",
		"The list of channels that bundle image belongs to")
	if err := cmd.MarkFlagRequired("channels"); err != nil {
		log.Fatalf("Failed to mark `channels` flag for `build` subcommand as required")
	}
	cmd.Flags().StringVarP(&c.imageTag, "tag", "t", "",
		"The image tag applied to the bundle image")
	if err := cmd.MarkFlagRequired("tag"); err != nil {
		log.Fatalf("Failed to mark `tag` flag for `build` subcommand as required")
	}

	cmd.Flags().StringVarP(&c.imageBuilder, "image-builder", "b", "docker",
		"Tool to build container images. One of: [docker, podman, buildah]")
	cmd.Flags().StringVarP(&c.channelDefault, "default", "e", "",
		"The default channel for the bundle image")
	cmd.Flags().BoolVarP(&c.overwrite, "overwrite", "o", false,
		"To overwrite annotations.yaml locally if existed. By default, overwrite is set to `false`.")

	return cmd
}
