// Copyright 2019 The Operator-SDK Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package olm

import (
	"context"
	"fmt"
	"time"

	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/pflag"
)

// TODO(estroz): figure out a good way to deal with creating scorecard objects
// and injecting proxy container

const (
	DefaultTimeout = time.Minute * 2

	defaultNamespace = "default"
)

// OLMCmd configures deployment and teardown of an operator via an OLM
// installation existing on a cluster.
type OLMCmd struct {
	// ManifestsDir is a directory containing a package manifest and N bundles
	// of the operator's CSV and CRD's. OperatorVersion can be set to the
	// version of the desired operator version's subdir and Up()/Down() will
	// deploy the operator version in that subdir.
	ManifestsDir string
	// OperatorVersion is the version of the operator to deploy. It must be
	// a semantic version, ex. 0.0.1.
	OperatorVersion string
	// IncludePaths are path to manifests of Kubernetes resources that either
	// supplement or override defaults generated by methods of OLMCmd. These
	// manifests can be but are not limited to: RBAC, Subscriptions,
	// CatalogSources, OperatorGroups.
	//
	// Kinds that are overridden if supplied:
	// - CatalogSource
	// - Subscription
	// - OperatorGroup
	IncludePaths []string

	// KubeconfigPath is the local path to a kubeconfig. This uses well-defined
	// default loading rules to load the config if empty.
	KubeconfigPath string
	// OperatorNamespace is the cluster namespace in which operator resources
	// are created.
	OperatorNamespace string
	// Timeout dictates how long to wait for a REST call to complete. A call
	// exceeding Timeout will generate an error.
	Timeout time.Duration
	// Force forces overwriting/deleting of all resources, including registries,
	// respectively
	Force bool
}

func (c *OLMCmd) AddToFlagSet(fs *pflag.FlagSet) {
	fs.StringVar(&c.OperatorVersion, "operator-version", "", "Version of operator to deploy")
	fs.StringSliceVar(&c.IncludePaths, "include", nil, "Path to Kubernetes resource manifests, ex. Role, Subscription. These supplement or override defaults generated by up/down")
	fs.StringVar(&c.KubeconfigPath, "kubeconfig", "", "Path to kubeconfig")
	fs.StringVar(&c.OperatorNamespace, "namespace", "", "Namespace in which to create resources")
	fs.DurationVar(&c.Timeout, "timeout", DefaultTimeout, "Time to wait for the command to complete before failing")
	fs.BoolVar(&c.Force, "force", false, "Force operator-sdk up/down to overwrite/delete all resources known to the command, respectively")
}

func (c *OLMCmd) validate() error {
	if c.ManifestsDir == "" {
		return fmt.Errorf("manifests dir must be set")
	}
	if c.OperatorVersion == "" {
		return fmt.Errorf("operator version must be set")
	}
	return nil
}

func (c *OLMCmd) initialize() {
	if c.Timeout <= 0 {
		c.Timeout = DefaultTimeout
	}
}

func (c *OLMCmd) Up() error {
	if err := c.validate(); err != nil {
		return errors.Wrapf(err, "validation error")
	}
	m, err := c.newManager()
	if err != nil {
		return errors.Wrap(err, "error initializing operator manager")
	}
	ctx, cancel := context.WithTimeout(context.Background(), c.Timeout)
	defer cancel()
	if err = m.up(ctx); err != nil {
		log.Fatalf("Failed to install operator: %v", err)
	}
	return nil
}

func (c *OLMCmd) Down() (err error) {
	if err := c.validate(); err != nil {
		return errors.Wrapf(err, "validation error")
	}
	m, err := c.newManager()
	if err != nil {
		return errors.Wrap(err, "error initializing operator manager")
	}
	ctx, cancel := context.WithTimeout(context.Background(), c.Timeout)
	defer cancel()
	if err = m.down(ctx); err != nil {
		log.Fatalf("Failed to uninstall operator: %v", err)
	}
	return nil
}
